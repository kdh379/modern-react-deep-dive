# 7 크롬 개발자 도구란

- 시크릿 모드에서 사용할 것을 추천한다.
  - 확장 프로그램의 영향으로 디버깅에 어려움이 있을 수 있다.
- 리액트 외에서 발생하는 이슈는 크롬 개발자 도구를 통해 분석해야 한다.  
- JS 메모리, 네트워크, 소스, 실제 HTML 및 CSS 등을 확인할 수 있다.

## 7.2 요소 탭

- HTML, 스타일, 이벤트 리스너, 중단점, 속성, 접근성 등을 확인할 수 있다.
- 직접 HTML, CSS를 수정하여 HotReload 없이 바로 적용해 볼 수 있다.
- 요소에 **중단 위치**를 지정하면, 해당 요소를 변경시킨 소스코드를 보여준다.

## 7.3 소스 탭

- 페이지를 불러오기 위해 실행하거나 참조된 모든 파일을 확인할 수 있다.
- 개발모드에선, 압축되기 이전 소스파일을 확인할 수 있다.
  - 파일 열기 명령어를 통해, 파일명 입력
- **아래 내용을 알게되면 `console.log`를 작성할 일이 줄어들 것이다.**
- 소스 코드에 **중단점**을 지정하면, JS 코드 실행을 잠시 멈추고 변수 값을 확인할 수 있다.
  - JAVA IDE에서 사용하는 것과 동일한 방식으로 디버깅을 진행해볼 수 있다.

### 소스 탭 주요 목록

- **감시**: 원하는 변수명을 지정하면, 변수 값을 실시간으로 확인할 수 있다.
- **중단점**: 웹사이트내 추가한 모든 중단점 표시
- **범위**: 현재 중단점에서의 로컬 스코프 표시
- **호출 스택**: 현재 중단점의 콜스택 표시. 현재 JS의 실행 콘텍스트를 확인할 수 있다.
- **전역 리스너**: 현재 전역 스코프에 추가된 모든 이벤트 리스너 표시
- **XHR/가져오기, DOM, 이벤트 리스너, CSP 위반 중단점**: 소스의 중단점 이외 다양한 중단점 확인 가능

## 7.4 네트워크 탭

- 웹 접속 이후 발생한 모든 네트워크 요청을 확인할 수 있다.
  - Fetch/XHR, JS, CSS, 이미지 등 원하는걸 필터하여 확인할 수 있다.

React 개발 시, 불필요한 Fetch 요청이 발생하는 경우가 잦다.  
또한 모바일 지원 웹 개발 시, 데이터 사용량에 민감할 수 있다.  

`스크린샷 캡쳐`기능을 통해, 네트워크 요청 흐름에 따라 웹페이지가 어떻게 보이는지 확인할 수 있다.  
아래의 내용을 집중적으로 확인해보자.

- 불필요한 요청 또는 중복 요청이 없는지
- 웹페이지 구성에 필요한 리소스가 너무 크지 않은지
- 리소스를 불러오는 속도는 적절한지
- 리소스가 올바른 우선순위로 다운로드되어 페이지를 자연스럽게 만들어가는지

## 7.5 메모리 탭

- 현재 웹페이지가 차지중인 메모리 관련 정보를 확인할 수 있다.
- 메모리탭은 **프로파일링** 이후 정보를 확인해야 하는데, 3가지 프로파일링 유형이 존재한다.
  - **힙 스냅샷**: 현재 메모리 상황을 확인
  - **타임라인의 할당 게측**: 시간의 흐름에 따라 메모리 변화 확인. 아래와 같은 경우 사용하면 좋다.
    - 로딩이 되는 과정
    - 페이지 내 상호작용
  - **할당 샘플링**: 메모리 공간을 차지중인 JS 함수를 표시

### 7.5.1 자바스크립트 인스턴스 VM 선택

- 프로파일링에 앞서 아래 항목을 통해 현재 실행중인 자바스크립트 VM 인스턴스를 확인할 수 있다.
- 여기서 개발자가 디버깅할 자바스크립트 인스턴스를 선택해야 한다.
- 이 크기만큼 사용자에게 부담을 주므로, 불필요하게 크기가 늘어나지 않는지 확인해야 한다.

### 7.5.2 힙 스냅샷

- 현재의 메모리 상태를 표시해준다.
- 하나의 스냅샷보단, 2개 이상의 스냅샷을 비교하여 메모리 사용량을 확인하는 것이 좋다.

#### 디버깅 방법

1. 페이지 로딩이 완료되면 힙 스냅샷을 실행한다.
2. 웹페이지에서 디버깅할 구간 혹은 상호작용을 수행한다.
3. 힙 스냅샷을 다시 실행한다.
4. 메모리 탭 상단에서, **모든 객체**를 클릭한 후, **스냅샷 1에서 스냅샷 2 사이에 할당된 객체**를 클릭한다.
5. **얕은 크기** 항목을 기준으로 메모리 사용량을 확인한다.
6. 확인할 **생성자**를 클릭 후, 하단 객체 탭에서 확인할 수 있으며, 필요에 따라 우클릭 후 **전역 변수로 저장**하면 **콘솔 탭**에서 확인할 수 있다.

> 얕은 크기와 유지된 크기의 차이
> 
> 얕은 크기는 객체가 보유한 메모리 바이트의 크기를 나타낸다.  
> 유지된 크기는 해당 객체 및 다른 부모가 존재하지 않는 모든 객체들의 크기까지 더한 값이다.

#### 리액트 훅도 메모리에서 확인해볼 수 있다.

1. 위와 동일하게, 페이지 로딩이 완료되면 힙 스냅샷을 실행한다.
2. useState의 setState를 호출하는 함수를 작성한 후, 함수를 호출한다.
3. 힙 스냅샷을 다시 실행한다.

- 이 때 `(closure)` 항목을 살펴보면, 작성한 함수명과 파일명이 표시된다.  
- `setState((prev) => !prev)`와 같이 작성했을 경우, `(closure)`내에 익명함수 `()` 가 표시된다.
- 만일 useCallback을 사용하였고, 의존성이 변경되지 않았다면 `(closure)` 항목에 해당 함수가 표시되지 않을 것이다.

### 7.5.3 타임라인의 할당 게측

- 시간의 흐름에 따라 메모리 변화를 확인할 수 있는 기능이다.

#### 디버깅 방법

메모리 누수를 프로파일링 하기 위해, 아래와 같은 방법을 사용할 수 있다.

1. 페이지 로딩이 완료되면, **타임라인 할당의 계측**을 선택 후, 좌측상단 녹화시작 버튼을 누른다.
2. 상단에 시간에 따른 메모리 변화가 표시된다.
3. 웹페이지에서 상호작용 시, 메모리 사용량이 점점 늘어나는지 확인해본다.
4. 네트워크 탭과 동일하게, 특정 구간만 볼 수 있도록 확인할 수 있다.
5. 확인할 생성자를 클릭 후, 하단 객체에서 내용을 확인해볼 수 있다.
  - **전역 변수로 저장** 후, 콘솔 탭에서 확인할 수 있다.
  - React DOM 요소에 누수가 있을 경우 `FiberNode` 항목 크기가 점점 커진다.
  - 그외엔 `(array)` 혹은 `Object` 항목의 크기가 커지는지 확인해본다.

### 7.5.4 할당 샘플링

- 시간의 흐름에 따라 발생하는 메모리 점유를 확인할 수 있다는 점에선 타임라인 할당 게측과 비슷하나,
- JS 실행 스택별로 분석할 수 있고, 이 분석은 함수 단위로 이루어진다.

#### 디버깅 방법

1. 페이지 로딩이 완료되면, **할당 샘플링**을 선택 후, 샘플링할 VM을 선택하고 좌측상단 녹화시작 버튼을 누른다.
2. 웹 페이지에서 상호작용을 수행한다.
3. 녹화를 중단한다.

- 이 때 **각 함수가 메모리를 얼마나 사용하는지 확인할 수 있다.**
- 타임라인의 할당 계측보다 브라우저에 부담을 적게 줘서, 장시간 녹화해도 무리가 없다.
- 메모리 누수가 의심되지만, 발생 지점이 어딘지 알기 어려울 때, 할당 샘플링을 통해 확인할 수 있다.

## 7.6 Next.js 환경 디버깅하기

- 이전까지 내용은 클라이언트 측 디버깅이었다.
- Next.js 환경에서는 SSR을 수행하므로, 서버 측 디버깅도 필요하다.

### 7.6.1 Next.js 프로젝트를 디버그 모드로 실행하기

아래의 명령어를 통해, 디버그 모드로 실행할 수 있다.

```bash
npm run dev -- --inspect
```

package.json 파일에 아래의 내용을 추가한다.

```json
"scripts": {
  "dev": "NODE_OPTIONS=--inspect next dev"
}
```

디버그모드로 실행 시, 웹소캣 주소가 표시된다.

```bash
> Next.js 14.x
> 
> Ready - started server on 0.0.0.0:3000, url: http://localhost:3000

Debugger listening on ws://127.0.0.1:9222/b8d8......
```

크롬 브라우저에서, chrome://inspect 에 접속한다.
여기서 Open dedicated DevTools for Node 버튼을 클릭하면, 새창에 디버그 모드로 실행된 DevTools가 열린다.

### 7.6.2 Next.js 서버에 트래픽 유입시키기

서버에서 발생하는 메모리 누수는, 사용자의 유입이 증가하며 발생하는 경우가 많다.  
직접 트래픽을 유입시키는 방법은 아래와 같다.

오픈소스 도구인 [ab](https://httpd.apache.org/docs/2.4/programs/ab.html)를 사용한다.  
ab는 아파치 재단에서 제공하는 웹서버 성능 검사 도구이다.

터미널을 열고, 아래의 명령어를 입력한다.

```bash
ab -k -c 50 -n 10000 http://localhost:3000/
```

- `-k`: 연결을 유지한다.
- `-c`: 동시 사용자 수
- `-n`: 요청 횟수

이 명령어는 50개의 동시 사용자가 10,000번 요청을 보내는 것을 의미한다.  
위 명령을 실행 시 아래와 같이 출력된다.

```bash
This is ApacheBench, Version 2.3 <$Revision: 1879412 $>
Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking localhost (be patient)
Completed 1000 requests
Completed 2000 requests
Completed 3000 requests
Completed 4000 requests
Completed 5000 requests
Completed 6000 requests
Completed 7000 requests
Completed 8000 requests
Completed 9000 requests
Completed 10000 requests


Server Software:        Next.js
Server Hostname:        localhost
Server Port:            3000

Document Path:          /
Document Length:        1304 bytes

Concurrency Level:      50
Time taken for tests:   10.000 seconds
Complete requests:      10000
Failed requests:        0
Non-2xx responses:      10000

Total transferred:      13040000 bytes
HTML transferred:       13040000 bytes
Requests per second:    1000.00 [#/sec] (mean)
Time per request:       50.000 [ms] (mean)
Time per request:       50.000 [ms] (mean, across all concurrent requests)

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    0   0.0      0       0
Processing:    0   50  10.0     50     100
Waiting:        0   50  10.0     50     100
Total:         0   50  10.0     50     100

Percentage of the requests served within a certain time (ms)
  50%   10000
  66%   10000
  75%   10000
  80%   10000
  90%   10000
  95%   10000
  98%   10000
  99%   10000
  100%  10000 (longest request)
```

- ab를 사용하면, 요청 수행뿐만 아니라, 요청 시간, 응답 시간, 바이트 크기, 성공 여부 등을 확인할 수 있다.

### 7.6.3 Next.js의 메모리 누수 지점 확인하기

해당 도서는 Next.js Page Router를 기준으로 설명하고 있다.  
최근의 RSC는 직접 테스트가 필요해보임.

#### 디버깅 방법

1. next 애플리케이션을 디버그 모드로 실행한다.
2. next 애플리케이션을 방문한 뒤 **힙 스냅샷**을 실행한다.
3. 다시 방문하여 트래픽을 유입시킨다.
4. 힙 스냅샷을 다시 실행한다.

- PageRouter 기준, getServerSideProps의 크기가 커지며, 내부에 객체가 쌓이는걸 확인할 수 있다.
- 생성자 중, `Object`에서 반복 생성된 객체를 열어본 후 객체를 살펴보면,
  - system / context 에 위치해 있으며,
  - 그 경로가 {WORKSPACE_경로}/.next/server/... 에 위치해 있음을 확인할 수 있다.

next 앱에서 RSC 영역은, 모든 사용자가 호출하는 함수이므로 최대한 부수효과가 적은 함수를 작성해야 한다.

